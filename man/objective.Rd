% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/objective.R
\name{objective}
\alias{objective}
\title{Solver objective}
\usage{
objective(solver, data, misfit_fn = squared_error, param_transform = NULL, ...)
}
\arguments{
\item{solver}{object of class \code{solver}.}

\item{data}{observed ('exact') data.}

\item{misfit_fn}{function to compute misfit between \code{data} and result of
simulation.}

\item{param_transform}{function performing parameter transformation, must
accept 1 parameter \code{x} and return list with components \code{value} and
\code{jacobian}, the latter is optional if \code{solver} does not compute
derivatives.}

\item{...}{additional args passed to \code{\link[=run]{run()}}, note that some solvers can
have some mandatory parameters (see \code{\link[=required_args]{required_args()}}),
e.g. solvers created with \code{\link[=adaptive_shell_solver]{adaptive_shell_solver()}} require \code{precision}.}
}
\value{
Function with numeric parameter \code{x} returning list with one or two
components:
\describe{
\item{\code{value}}{numeric, objective value,}
\item{\code{gradient}}{numeric, objective gradient, missing if solver does not compute
Jacobian matrix.}
}
}
\description{
Function factory producing solver objective function returning value and
(possibly) gradient at the same time.
}
\examples{
s <- fake_adaptive_solver(4, 5)
result <- run(s, c(10, 10, 10, 10), precision = 5.0, silent = TRUE)
observed_data <- result$qoi
x <- c(10.5, 9.44, 10.21, 8.14)
solver_obj <- objective(s, observed_data, precision = 30.0, silent = TRUE)
solver_obj(x)
}
